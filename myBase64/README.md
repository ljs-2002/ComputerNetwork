# myBase64

[TOC]

## 原理
- 在`myBase64`类的`encoder()`方法中，会将要编码的字符串按字节6位一组划分；
- 将每一个6位组传入`__base64Encoder()`方法中进行编码，在该方法中会先查找当前的映射表得到编码后的字符，再调用`__getNewBase64Map()`方法更新映射表；
- 在`__getNewBase64Map()`方法中会根据此次编码的6位组的哈希值作为种子，生成一个长度为64的随机数列表`steps`，该列表中的每一个随机数代表需要交换的步长。之后遍历当前的映射表，对于第`i`位的字符，应与它之后第`steps[i]`个字符进行交换。所有交换完成后得到新的映射表；
- 由于当随机数种子确定时，其生成的随机数序列也是一样的，因此编码和解码双方可以生成相同的随机数序列。只要编码和解码双方提前协商好最初的映射表`initBase64Map`，就可以实现映射关系的自动搜索；

## 效果

- 经过测试，可以实现对同一字符串（含有中文和英文）连续重复编码300次以上不产生重复的编码；
- 若以纯英文字符串进行编码可以实现连续重复编码400次不产生重复的编码；
- 若对多个字符串进行重复编码，相同字符串产生重复编码的概率将会更低；
- 在实际使用中，对同一字符串连续重复编码的情况几乎不可能发生，因此本程序几乎不可能产生重复的编码，无法通过统计规律来判断编码对应的明文；而编码和解码双方提前协商好的映射表不泄露则攻击者无法得到编码过程中任何时刻的映射表，也就无法得到编码对应的明文，从而实现难以破译。

## 使用

### 初始化

- 在初始化时需要传入64位的初始映射表序列，以字符串表示。如：

  ```
  initBase64Map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  myEncoder = myBase64(initBase64Map)
  ```

- 使用`encoder()`方法进行编码，使用`decoder()`方法进行解码。

- 提供了`test.py`以进行测试。